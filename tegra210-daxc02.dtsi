/*
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <dt-bindings/media/camera.h>
#include <dt-bindings/platform/t210/t210.h>

/*
I2C Busses:

i2c0 = "/i2c@7000c000";
i2c1 = "/i2c@7000c400";
i2c2 = "/i2c@7000c500";
i2c3 = "/i2c@7000c700";
i2c4 = "/i2c@7000d000";
i2c5 = "/i2c@7000d100";
i2c6 = "/host1x/i2c@546c0000";
*/

/ {
    host1x {
        vi {
            num-channels = <0x1>;
            ports {
                #address-cells = <0x1>;
                #size-cells = <0x0>;

                port@0 {
                    reg = <0x0>;
                    status = "okay";
                    daxc02_vi_in0: endpoint {
                        status = "okay";
                        csi-port = <0x0>;
                        bus-width = <0x4>;
                        remote-endpoint = <&daxc02_out0>;
                    };
                };      
            };   
        };
        i2c@546c0000 {
            #address-cells = <1>;
            #size-cells = <0>;
            
            tps22994@70 {
            	compatible = "nova,tps22994";
            	reg = <0x70>;
            };

            daxc02@10 {
                compatible = "nova,daxc02";

                /* I2C device address */
                reg = <0x10>;

                /* Physical dimensions of sensor */
                physical_w = "10";
                physical_h = "10";

                /* Sensor Model */
                sensor_model ="mt9m021";

                /* input clock for the device in MHz*/
                mclk = "cam_mclk1";

                /* Define any required hw resources needed by driver */
                /* ie. clocks, io pins, power sources */
                vana-supply = <&max77620_ldo3>;  // analog 2.8v
                vif-supply = <&en_vdd_cam>;    // interface 1.8v
                vdig-supply = <&en_vdd_cam_1v2>; // digital 1.2v

                avdd-reg = "vana";
                iovdd-reg = "vif";
                dvdd-reg = "vdig";

                /* Defines number of frames to be dropped by driver internally after applying */
                /* sensor crop settings. Some sensors send corrupt frames after applying */
                /* crop co-ordinates */
                post_crop_frame_drop = "0";

                /* when set true analog gain value expressed in decibels." */
                use_decibel_gain = "false";


                /*
                * A modeX node is required to support v4l2 driver
                * implementation with NVIDIA camera software stack
                *
                * mclk_khz = "";
                * Standard MIPI driving clock, typically 24MHz
                *
                * num_lanes = "";
                * Number of lane channels sensor is programmed to output
                *
                * tegra_sinterface = "";
                * The base tegra serial interface lanes are connected to
                *
                * discontinuous_clk = "";
                * The sensor is programmed to use a discontinuous clock on MIPI lanes
                *
                * dpcm_enable = "true";
                * The sensor is programmed to use a DPCM modes
                *
                * cil_settletime = "";
                * MIPI lane settle time value.
                * A "0" value attempts to autocalibrate based on mclk_multiplier
                *
                *
                *
                *
                * active_w = "";
                * Pixel active region width
                *
                * active_h = "";
                * Pixel active region height
                *
                * pixel_t = "";
                * The sensor readout pixel pattern
                * For eg - 10 bit bayer having 'bggr' pixel pattern has value "bayer_bggr"
                *      12 bit bayer having 'bggr' pixel pattern has value "bayer_bggr12"
                *      14 bit bayer having 'bggr' pixel pattern has value "bayer_bggr14"
                *
                * readout_orientation = "0";
                * Based on camera module orientation.
                * Only change readout_orientation if you specifically
                * Program a different readout order for this mode
                *
                * line_length = "";
                * Pixel line length (width) for sensor mode.
                * This is used to calibrate features in our camera stack.
                *
                * mclk_multiplier = "";
                * Multiplier to MCLK to help time hardware capture sequence
                * TODO: Assign to PLL_Multiplier as well until fixed in core
                *
                * pix_clk_hz = "";
                * Sensor pixel clock used for calculations like exposure and framerate
                *
                *
                *
                *
                * inherent_gain = "";
                * Gain obtained inherently from mode (ie. pixel binning)
                *
                * min_gain_val = ""; (floor to 6 decimal places)
                * max_gain_val = ""; (floor to 6 decimal places)
                * Gain limits for mode
                *
                * min_exp_time = ""; (ceil to integer)
                * max_exp_time = ""; (ceil to integer)
                * Exposure Time limits for mode (us)
                *
                *
                * min_hdr_ratio = "";
                * max_hdr_ratio = "";
                * HDR Ratio limits for mode
                *
                * min_framerate = "";
                * max_framerate = "";
                * Framerate limits for mode (fps)
                *
                * embedded_metadata_height = "";
                * Sensor embedded metadata height in units of rows.
                * If sensor does not support embedded metadata value should be 0.
                */
                mode0 {
                    mclk_khz = "24000";
                    num_lanes = "4";
                    tegra_sinterface = "serial_c";
                    discontinuous_clk = "no";
                    dpcm_enable = "false";
                    cil_settletime = "0";

                    active_w = "1280";
                    active_h = "960";
                    pixel_t = "bayer_rggb12";
                    readout_orientation = "0";
                    line_length = "2688";
                    inherent_gain = "1";
                    mclk_multiplier = "3.094";
                    pix_clk_hz = "74250000";

                    min_gain_val = "1.0";
                    max_gain_val = "3.0";
                    min_hdr_ratio = "";
                    max_hdr_ratio = "";
                    min_framerate = "1";
                    max_framerate = "60";
                    min_exp_time = "1";
                    max_exp_time = "672";
                    embedded_metadata_height = "0";
                };
                ports {
                    #address-cells = <0x1>;
                    #size-cells = <0x0>;

                    port@0 {
                        reg = <0x0>;
                        daxc02_out0: endpoint {
                            csi-port = <0x0>;
                            bus-width = <0x4>;
                            remote-endpoint = <&daxc02_vi_in0>;
                        };
                    };
                };
            };
        };
    };

    tegra-camera-platform {
        compatible = "nvidia, tegra-camera-platform";
        modules {
            module0 {
                badge = "daxc02_master_mt9m021";
                position = "front";
                orientation = "1";
                status = "okay";
                drivernode0 {
                    pcl_id = "v4l2_sensor";
                    proc-device-tree = "/proc/device-tree/host1x/i2c@546c0000/daxc02@10";
                	status = "okay";
                };
                drivernode1 {
                    status = "okay";
                    pcl_id = "v4l2_focuser_stub";
                    proc-device-tree = [00];
                };
            };
        };
    };

    regulators {
        /* VDD_SYS_EN */
        en_vdd_cam: regulator@5 {
            regulator-boot-on;
            regulator-always-on;
        };

        /* CAM_VDD_2V8_EN */
        en_vdd_cam_hv_2v8: regulator@206 {
            regulator-boot-on;
            regulator-always-on;
        };

        /* CAM_VDD_1V8_EN */
        en_vdd_cam_1v8: regulator@211 {
            regulator-boot-on;
            regulator-always-on;
        };
		
        /* CAM_VDD_1V2_EN */
        en_vdd_cam_1v2: regulator@209 {
            regulator-boot-on;
            regulator-always-on;
        };
    };
};
